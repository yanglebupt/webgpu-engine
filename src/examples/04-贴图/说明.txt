其实 canvas 就是一个贴图 Texture

- TEXTURE_BINDING，代表我们可以在使用 renderPass 的 shader 中使用 `textureSample` 采样 texel 颜色值
- COPY_DST，代表我们可以拷贝值进入
- RENDER_ATTACHMENT，代表渲染的目标，例如 renderPass 中的 canvas，copyExternalImageToTexture 也是将图像渲染到 texture 中
- STORAGE_BINDING，代表我们在 computePass 的 shader 中可以用作存储贴图，可读可写，普通的贴图只能读


一些方法

- textureDimensions 获取贴图的维度，可以指定 level (`u32/i32`) 参数获取 miplevel 级别的图像维度，不需要插值，任意贴图都可以使用
- textureLoad 获取贴图像素点，可以指定 array_index 和 level 获取指定贴图，不过没有 filter，也就是参数必须是 `u32/i32`，任意贴图都可以使用
- textureSample/textureSampleLevel 通过 uv 采样中才对 level (`f32`) 有 filter，array_index (`u32/i32`) 不需要 filter。
  但是 storage texture 不能使用，因为其不需要使用 sampler，也就不存在插值，因此只能用 textureLoad/textureStore 读写 pixel
- storage texture 不能有 miplevel，所有的方法都没有 level 这个参数，只有 array_index 这个参数


@must_use fn textureLoad(t: texture_2d<ST>,
                         coords: vec2<C>,
                         level: L) -> vec4<ST>

@must_use fn textureLoad(t : texture_storage_2d<F, AM>,
                         coords : vec2<C>) -> vec4<CF>

但是我们在创建 device.createTexture 时绑定了 STORAGE_BINDING，还是可以设置 mipLevelCount 这个参数。
只不过在 binding 的时候，如果 shader 中声明的是 texture_storage_2d 则必须指定一个特定的 baseMipLevel 和 mipLevelCount = 1

当然你也可以在 shader 中声明 texture_2d，尽管创建 device.createTexture 时绑定了 STORAGE_BINDING